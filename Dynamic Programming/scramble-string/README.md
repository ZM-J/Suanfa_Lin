###  87. Scramble String

## 题目网址
https://leetcode.com/problems/scramble-string/description/
## markdown在线编辑&查看
https://www.zybuluo.com/mdeditor
## 题目适当转述
无

## 我的做法
一开始直接的想法便是分治来解决这个问题。

设求解函数为$f(s_1,s_2)$，其中$|s_1|=|s_2|=l$。

先检查$s_1$是否与$s_2$相等。若是的话，那么$f(s_1,s_2)$为真。

之后枚举所有的$i$。

* 看$s_1$的前$i$个字符能否与$s_2$的前$i$个字符匹配，同时$s_1$的后$l-i$个字符能否与$s_2$的后$l-i$个字符匹配。

* 看$s_1$的后$i$个字符能否与$s_2$的前$i$个字符匹配，同时$s_1$的前$l-i$个字符能否与$s_2$的后$l-i$个字符匹配。

若有一个匹配成功的话，那么$f(s_1,s_2)$为真，否则为假。

这样做的话，由于算法复杂度为$O(C_l)$，其中$C_n$为第$n$个卡塔兰数。这个复杂度是相当高的，以至于会超时。所以我们必须进行剪枝。

1. 引入一个缓存$f$，记录已经求过的$f(s_1,s_2)$的值以避免重复求值。
2. 在检查相等之后，统计$s_1$与$s_2$的字母频数分布。如果$s_1$与$s_2$的频数分布不同的话，那么$f(s_1,s_2)$必为假。这个优化是重点，因为它可以帮助我们否定掉许多不可能的条件，从而使算法运行时间降低。


## 复杂度分析
算法的时间复杂度为$O(C_l)$（其本质上还是与之前的算法同阶）。

算法的空间复杂度也为$O(l^2)$（考虑到缓存$f$的引入）。
